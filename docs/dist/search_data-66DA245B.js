searchData={"items":[{"type":"module","title":"ConcreteOptics","doc":"Re-export module for convenience. Includes all standard optics\nand optic constructors. See the README file for the general design\nand usage examples.","ref":"ConcreteOptics.html"},{"type":"module","title":"ConcreteOptics.Core","doc":"Core structure carrying the optic capabilities and basic functionality around it.","ref":"ConcreteOptics.Core.html"},{"type":"type","title":"ConcreteOptics.Core.optics/0","doc":"Complete list of supported optics.","ref":"ConcreteOptics.Core.html#t:optics/0"},{"type":"type","title":"ConcreteOptics.Core.tp/4","doc":"","ref":"ConcreteOptics.Core.html#t:tp/4"},{"type":"function","title":"ConcreteOptics.Core.classify/1","doc":"Determines the type of a lawful optic by inspecting which capabilities it has.","ref":"ConcreteOptics.Core.html#classify/1"},{"type":"function","title":"ConcreteOptics.Core.compose/2","doc":"General optic composition.","ref":"ConcreteOptics.Core.html#compose/2"},{"type":"module","title":"ConcreteOptics.Iso","doc":"Isomorphisms as optics.","ref":"ConcreteOptics.Iso.html"},{"type":"extras","title":"Introduction","doc":"# Introduction to ConcreteOptics","ref":"intro.html"},{"type":"extras","title":"TL;DR - Introduction","doc":"Optics are general and composable constructions that allow bidirectional access to immutable data.\n\nHere is an example of an optic --a traversal to be more precise-- which focuses on positive elements with key `:a` inside a map inside a vector.\n\n```elixir\n#TODO\n```","ref":"intro.html#tl-dr"},{"type":"extras","title":"Implementation Idea - Introduction","doc":"The idea is from [concrete optics for clojure](https://github.com/sonatsuer/concrete-optics). The implementation and documentation are adapted from that repo.\n\nThere is a very general [definition](https://ncatlab.org/nlab/show/optic+%28in+computer+science%29) of optics which relies on a nontrivial amount of mathematical background. We will not be working with that here. Instead, we will take a more *concrete* approach and work with certain capabilities an optic can have. Behind the curtains, each optic will be a map of capabilities.\n\nAs a simple mental model, we can think of an optic connecting a *big* whole to a *small* part. Sometimes we say that the optic focuses on the small part. Here is a list of capabilities with their intuitive meanings:\n\n* **view**: Gives you the small part of the whole. Typically field accessors are views.\n* **to_list**: Very much like **view**, but instead of a single element it focuses on many --possibly zero-- elements.\n* **review**: Given an element of the small part, constructs a big whole. Typically sum type constructors are reviews.\n* **over**: Turns a transformation over the small part into a transformation of the whole.\n* **traverse**: Allows you to perform a \"structured for loop\" over the focus.\n\nThere are also formal laws we expect these capabilities to satisfy. You can find their precise formulations in the test modules.\n\nHere is a table which classifies optics in terms of their capabilities.\n\n|               |  view | to_list| review | over | traverse |\n| ------------- |:-----:|:------:|:------:|:----:|:--------:|\n| isomorphism   |   ✓   |    ✓   |   ✓    |  ✓   |    ✓     |\n| lens          |   ✓   |    ✓   |        |  ✓   |    ✓     |\n| prism         |       |    ✓   |   ✓    |  ✓   |    ✓     |\n| traversal     |       |    ✓   |        |  ✓   |    ✓     |\n\nWhen we compose two optics, we compose their corresponding capabilities. If a capability is not a common capability of the optics then it is lost. For instance composition of two optics of the same kind is another of the same kind. An optic and its composition with an isomorphism are of the same kind since isomorphisms have all the capabilities. But the composition of a prism and a lens is a traversal.","ref":"intro.html#implementation-idea"},{"type":"extras","title":"What is Missing - Introduction","doc":"This framework can easily support the optics `getter` (which has `view` and `to_list`), `setter` (which has `over`) and `fold` (which has `to_list`). I omitted them since they are not as useful.\n\nThere is a general notion duality in optics where you change the roles of the whole and the piece. For instance the function `invert-iso` is an implementation of this idea. However, in this capability only formalism, it is not possible to invert, say, a prism twice and get the original prism. The system can certainly be expanded to support this, though.\n\nExotic optics like grates or achromatic lenses are not implemented because, well, they are exotic and implementing them  would require a change in the current design which is dead simple.","ref":"intro.html#what-is-missing"},{"type":"extras","title":"Showcase","doc":"# Showcase\n\n```elixir\ndefmodule ConcreteOpticsTest do\n  @moduledoc \"\"\"\n  This test file is a showcase of optics supported by the library.\n  \"\"\"\n  use ExUnit.Case\n\n\n  test \"greets the world\" do\n    assert ConcreteOptics.hello() == :world\n  end\nend\n```","ref":"showcase.html"}],"proglang":"elixir","content_type":"text/markdown","producer":{"name":"ex_doc","version":"0.38.4"}}